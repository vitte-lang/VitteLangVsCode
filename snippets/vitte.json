{
  "Module": {
    "prefix": ["module"],
    "body": ["module ${1:core.module}", "$0"],
    "description": "Déclaration du module courant"
  },
  "Import": {
    "prefix": ["import"],
    "body": ["import ${1:core.module}${2: as ${3:alias}}", "$0"],
    "description": "Import d’un module ou alias facultatif"
  },
  "Struct": {
    "prefix": ["struct"],
    "body": [
      "struct ${1:Name}",
      "    let ${2:field}: ${3:Type}",
      ".end",
      "$0"
    ],
    "description": "Structure with fields (.end)"
  },
  "Union": {
    "prefix": ["union"],
    "body": [
      "union ${1:Name}",
      "    let ${2:field}: ${3:Type}",
      ".end",
      "$0"
    ],
    "description": "Union with variants (.end)"
  },
  "Enum": {
    "prefix": ["enum"],
    "body": [
      "enum ${1:Name}",
      "    ${2:Variant1}",
      "    ${3:Variant2}",
      ".end",
      "$0"
    ],
    "description": "Enumeration (.end)"
  },
  "Typedef": {
    "prefix": ["typedef"],
    "body": ["typedef ${1:Existing} ${2:Alias}", "$0"],
    "description": "Type alias"
  },
  "Function": {
    "prefix": ["fn"],
    "body": [
      "fn ${1:name}(${2:param}: ${3:Type})${4: -> ${5:Return}}",
      "    ${0}",
      ".end"
    ],
    "description": "Function definition (.end)"
  },
  "Scenario": {
    "prefix": ["scenario", "scn"],
    "body": [
      "scenario ${1:name}(${2:param}: ${3:Type})",
      "    ${0}",
      ".end"
    ],
    "description": "Scenario (.end)"
  },
  "Program Entry": {
    "prefix": ["program", "prog"],
    "body": [
      "program ${1:module.path}",
      "    ${0}",
      ".end"
    ],
    "description": "Program entry (.end)"
  },
  "Type Block (phrase)": {
    "prefix": ["type", "field"],
    "body": [
      "type ${1:Name}",
      "    field ${2:x} : ${3:Type}",
      "    field ${4:y} : ${5:Type}",
      ".end",
      "$0"
    ],
    "description": "Phrase syntax type/field (.end)"
  },
  "Match": {
    "prefix": ["match"],
    "body": [
      "match ${1:expr}",
      "    ${2:pattern} =>",
      "        ${3:expr}",
      "    _ =>",
      "        ${4:default}",
      ".end",
      "$0"
    ],
    "description": "Expression match avec .end"
  },
  "If / Else": {
    "prefix": ["if"],
    "body": [
      "if ${1:cond}",
      "    ${2}",
      "elif ${3:other}",
      "    ${4}",
      "else",
      "    ${0}",
      ".end"
    ],
    "description": "Bloc conditionnel (.end)"
  },
  "While": {
    "prefix": ["while"],
    "body": [
      "while ${1:cond}",
      "    ${0}",
      ".end"
    ],
    "description": "Boucle while (.end)"
  },
  "For": {
    "prefix": ["for"],
    "body": [
      "for ${1:item} in ${2:iterable}",
      "    ${0}",
      ".end"
    ],
    "description": "Boucle for-in (.end)"
  },
  "Loop (from/to/step)": {
    "prefix": ["loop"],
    "body": [
      "loop ${1:i} from ${2:0} to ${3:10} step ${4:1}",
      "    ${0}",
      ".end"
    ],
    "description": "Phrase loop with from/to/step (.end)"
  },
  "When": {
    "prefix": ["when"],
    "body": [
      "when ${1:condition}",
      "    ${2}",
      "else when ${3:other}",
      "    ${4}",
      "else",
      "    ${0}",
      ".end"
    ],
    "description": "Phrase when/else chain (.end)"
  },
  "Set": {
    "prefix": ["set"],
    "body": ["set ${1:target} = ${2:value}", "$0"],
    "description": "Assignment (phrase syntax)"
  },
  "Say": {
    "prefix": ["say"],
    "body": ["say \"${1:message}\"", "$0"],
    "description": "Standard output (phrase syntax)"
  },
  "Do": {
    "prefix": ["do"],
    "body": ["do ${1:action} ${2:arg}", "$0"],
    "description": "Invoke an action (phrase syntax)"
  },
  "Return": {
    "prefix": ["ret", "return"],
    "body": ["ret ${1:value}", "$0"],
    "description": "Return a value (phrase or core syntax)"
  }
}
